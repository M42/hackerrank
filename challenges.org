#+TITLE: Programming Challenges
#+AUTHOR: Mario Rom√°n

* Algorithms
** Sorting
*** Bubble sort
An average performance of ${\cal O}(n^2)$.

**** C++ Implementation
#+BEGIN_SRC cpp :cmdline <<< '9 5 7 3 6 2 8 4 1'
  #include<iostream>
  #include<vector>
  using namespace std;

  void bubblesort(vector<int>& arr) {
    for (unsigned i=0; i<arr.size(); i++) {
      for (unsigned j=0; j<arr.size()-i-1; j++) {
        if (arr[j] > arr[j+1]) {
          int swap = arr[j];
          arr[j] = arr[j+1];
          arr[j+1] = swap;
        }
      }
    }
  }


  int main() {
    vector<int> numbers;
    int read;

    while (cin >> read) {
      numbers.push_back(read);
    }

    bubblesort(numbers);

    for (int n : numbers) {
      cout << n << " ";
    }
  }
#+END_SRC

#+RESULTS:
: 1 2 3 4 5 6 7 8 9

*** Quicksort
An average performance of ${\cal O}(n \log(n))$, but the worst-case performance is of ${\cal O}(n^2)$.

**** C++ Implementation
:cmdline <<< '9 5 7 3 6 2 8 4 1'
#+BEGIN_SRC cpp :cmdline <<< '7 6 5 4 3 2 1'
  #include<iostream>
  #include<vector>
  using namespace std;

  void quicksort(vector<int>& numbers, int left, int right) {
    if (left >= right)
      return;

    int i = left+1;
    int j = right;
    int pivot = numbers[left];

    while (i <= j) {
      while (numbers[i] < pivot)
        i++;
      while (numbers[j] > pivot)
        j--;
      if (i < j) {
        int swap = numbers[i];
        numbers[i] = numbers[j];
        numbers[j] = swap;
      }
    }

    numbers[left] = numbers[j];
    numbers[j] = pivot;
    quicksort(numbers, left, j-1);
    quicksort(numbers, j+1, right);
  }

  int main() {
    int read;
    vector<int> numbers;
    while (cin >> read)
      numbers.push_back(read);

    quicksort(numbers,0,numbers.size()-1);

    for (int n : numbers)
      cout << n << " ";
  }
#+END_SRC

#+RESULTS:
: 1 2 3 4 5 6 7

**** Haskell Implementation
#+BEGIN_SRC haskell :results output
  input :: [Int]
  input = [9,5,8,3,7,4,1,2,6]

  quicksort :: (Ord a) => [a] -> [a]
  quicksort [] = []
  quicksort (x:xs) =
    quicksort (filter (<=x) xs) ++
    [x] ++
    quicksort (filter (>=x) xs)

  main :: IO ()
  main = do
    print $ quicksort input
#+END_SRC

#+RESULTS:
: [1,2,3,4,5,6,7,8,9]

*** Mergesort
**** C++ Implementation
Mergesort has an average performance of ${\cal O}(n \log(n))$, where $n$ is the size of the arrray.
We can compute that visualizing a diagram of mergesort. To merge a level into other is lineal
in time, and to sort a level depends on the numbers of levels below it; if we think of the
diagram as a tree, it has $\log(n)$ levels.
#+BEGIN_SRC cpp :cmdline <<< '8 6 2 4 7 1 5 9 3'
  #include<iostream>
  #include<vector>
  using namespace std;

  void merge(vector<int>& arr, int left, int middle, int right) {
    vector<int> auxiliar;
    for (int i=left; i<right; i++)
      auxiliar.push_back(arr[i]);

    int rel_left = left-left;
    int rel_right = right-left;
    int rel_middle = middle-left;
    int i = rel_left;
    int j = rel_middle;
    int a = left;

    while (i < rel_middle and j < rel_right) {
      if (auxiliar[i] < auxiliar[j]) {
        arr[a] = auxiliar[i];
        i++; a++;
      }
      else {
        arr[a] = auxiliar[j];
        j++; a++;
      }
    }

    while (i < rel_middle) {
      arr[a] = auxiliar[i];
      i++; a++;
    }

    while (j < rel_right) {
      arr[a] = auxiliar[j];
      j++; a++;
    }
  }

  void mergesort(vector<int>& arr, int left, int right) {
    if (left >= right-1)
      return;

    int middle = (left+right)/2;
    mergesort(arr, left, middle);
    mergesort(arr, middle, right);
    merge(arr, left, middle, right);
  }

  int main() {
    vector<int> numbers;
    int read;
    while (cin >> read)
      numbers.push_back(read);

    mergesort(numbers, 0, numbers.size());

    for (int n : numbers) {
      cout << n << " ";
    }
  }

#+END_SRC

#+RESULTS:
: 1 2 3 4 5 6 7 8 9

**** Haskell implementation
#+BEGIN_SRC haskell :results output
  merge :: (Ord a) => [a] -> [a] -> [a]
  merge [] ys = ys
  merge xs [] = xs
  merge (x:xs) (y:ys)
      | x < y = x:(merge xs (y:ys))
      | otherwise = y:(merge (x:xs) ys)

  mergesort :: (Ord a) => [a] -> [a]
  mergesort [] = []
  mergesort [x] = [x]
  mergesort xs = merge (mergesort fs) (mergesort ls)
      where (fs,ls) = splitAt middle xs
            middle = div (length xs) 2

  main :: IO ()
  main = print $ mergesort input
  
  input :: [Int]
  input = [9,5,8,2,4,7,6,1,3,10]
#+END_SRC

#+RESULTS:
: [1,2,3,4,5,6,7,8,9,10]

*** Heapsort
It runs in ${\cal O}(n \log n)$.
**** Haskell library implementation
#+BEGIN_SRC haskell :results output
import Data.Heap as Heap

heapsort :: (Ord a) => [a] -> [a]
heapsort = Heap.sort

main :: IO ()
main = print $ heapsort input

input :: [Int]
input = [7,1,4,9,2,6,3,5,8]
#+END_SRC

#+RESULTS:
: [1,2,3,4,5,6,7,8,9]

** Data Structures
*** TODO Monoids and Finger Trees
**** Finger Trees
This code is based upon the article: [[http://apfelmus.nfshost.com/articles/monoid-fingertree.html][Monoids and fingertrees]] by Apfelmus.

#+BEGIN_SRC haskell :results output
  data Tree v a = Leaf v a
                | Branch v (Tree v a) (Tree v a)

  toList :: Tree v a -> [a]
  toList (Leaf _ x) = [x]
  toList (Branch _ xt yt) = toList xt ++ toList yt

  tag :: Tree v a -> v
  tag (Leaf v _) = v
  tag (Branch v _ _) = v


  -- Size trees with special constructors
  type Size = Int

  leaf :: a -> Tree Size a
  leaf x = Leaf 1 x

  branch :: Tree Size a -> Tree Size a -> Tree Size a
  branch xt yt = Branch (tag xt + tag yt) xt yt

  (!) :: Tree Size a -> Int -> a
  (!) (Leaf _ a) 0 = a
  (!) (Branch _ xt yt) n 
      | n < tag xt = xt ! n
      | otherwise  = yt ! (n - tag xt)

  fromList :: [a] -> Tree Size a
  fromList [x] = leaf x
  fromList xs = branch (fromList fh) (fromList sh)
      where
        (fh,sh) = splitAt (length xs `div` 2) xs


  -- Priority queue
  type Priority = Int

  leafp :: a -> Priority -> Tree Priority a
  leafp x p = Leaf p x

  branchp :: Tree Priority a -> Tree Priority a -> Tree Priority a
  branchp lt rt = Branch (min (tag lt) (tag rt)) lt rt

  winner :: Tree Priority a -> a
  winner (Leaf _ a) = a
  winner t@(Branch _ x y)
    | tag t == tag x = winner x
    | otherwise      = winner y

  fromListp :: [(a,Priority)] -> Tree Priority a
  fromListp [(x,p)] = leafp x p
  fromListp xs = branchp (fromListp fh) (fromListp sh)
      where
        (fh,sh) = splitAt (length xs `div` 2) xs


  -- Example main
  main :: IO ()
  main = do
    print $ fromList [7,5,2,6,4,9,1,3,8] ! 5
    print $ winner $ fromListp [("a",5),("b",7),("c",3),("d",4)]
#+END_SRC

#+RESULTS:
: 9
: c

**** Monoidal abstraction
We can abstract this into a monoid:

#+BEGIN_SRC haskell :results output

#+END_SRC

* Hackerrank
** Data Structures
*** Heap
**** Find the running median
#+BEGIN_SRC c++
#include<iostream>
#include<iomanip>
#include<vector>

using namespace std;

bool lesst(int a,int b) {return a < b;}
bool moret(int a,int b) {return a > b;}


void insert(vector<int>& max_heap, bool (*compare)(int,int), int a) {
  max_heap.push_back(a);
  int pointer = max_heap.size()-1;
  int parent = (pointer-1)/2;
  
  while (pointer != 0 and compare(max_heap[parent],max_heap[pointer])) {
    int swap = max_heap[pointer];
    max_heap[pointer] = max_heap[parent];
    max_heap[parent] = swap;

    pointer = parent;
    parent = (pointer-1)/2;
  }
}


// compare < max_heap -> lesser
// compare > min_heap -> greater
int pop(vector<int>& max_heap, bool (*compare)(int,int)) {
  int result = max_heap[0];
  max_heap[0] = max_heap[max_heap.size()-1];
  max_heap.resize(max_heap.size()-1);
  unsigned pointer = 0;
  bool change_left =
    ((pointer*2+1) < max_heap.size()) and compare(max_heap[pointer], max_heap[pointer*2+1]);
  bool change_right =
    ((pointer*2+2) < max_heap.size()) and compare(max_heap[pointer], max_heap[pointer*2+2]);
  
  while (change_left or change_right) {
    if (change_left and change_right) {
      if (compare(max_heap[pointer*2+1],max_heap[pointer*2+2]))
	change_left = false;
      else
	change_right = false;
    }
    if (change_left) {
    int swap = max_heap[pointer];
      max_heap[pointer] = max_heap[pointer*2+1];
      max_heap[pointer*2+1] = swap;
      pointer = pointer*2+1;
    }
    else if (change_right) {
      int swap = max_heap[pointer];
      max_heap[pointer] = max_heap[pointer*2+2];
      max_heap[pointer*2+2] = swap;
      pointer = pointer*2+2;
    }

    change_left =
      ((pointer*2+1) < max_heap.size()) and compare(max_heap[pointer], max_heap[pointer*2+1]);
    change_right =
      ((pointer*2+2) < max_heap.size()) and compare(max_heap[pointer], max_heap[pointer*2+2]);
  }

  return result;
}

int main() {
  cout << fixed << setprecision(1);
  int n; cin >> n;
  vector<int> max_heap;
  vector<int> min_heap;
  float median = 0;
  int diff = 0;
  int read;

  // First element
  cin >> read;
  max_heap.push_back(read);
  median = read;
  diff = 1;
  cout << float(median) << endl;

  // All elements
  for (int i=0; i<n-1; i++) {
    // Inserts new element
    cin >> read;
    
    if (read >= median) {
      insert(min_heap,moret,read);
      if (min_heap.size() > max_heap.size())
	insert(max_heap,lesst,pop(min_heap,moret));
    }

    if (read < median) {
      insert(max_heap,lesst,read);
      if (max_heap.size() > min_heap.size()+1)
	insert(min_heap,moret,pop(max_heap,lesst));
    }
    
    // Recomputes median
    if (i%2 == 0)
      median = (max_heap[0] + min_heap[0])/2.0;
    else
      median = (max_heap[0]);
    cout << float(median) << endl;

    // cerr << "max: [";
    // for (unsigned i=0; i<max_heap.size();i++)
    //   cerr <<max_heap[i] << ",";
    // cerr << "]\n";
    // cerr << "min: [";
    // for (unsigned i=0; i<min_heap.size();i++)
    //   cerr <<min_heap[i] << ",";
    // cerr << "]\n";
  }
}
#+END_SRC

** Functional Programming
*** Introduction
**** Solve me first FP
#+BEGIN_SRC haskell
solveMeFirst a b = a + b

main = do
    val1 <- readLn
    val2 <- readLn
    let sum = solveMeFirst val1 val2
    print sum
#+END_SRC

**** Hello world
#+BEGIN_SRC haskell
hello_world = putStrLn "Hello World"
main = do
   hello_world
#+END_SRC

**** Hello world N times
#+BEGIN_SRC haskell
hello_worlds n = mapM_ putStrLn (replicate n "Hello World")
main = do
   n <- readLn :: IO Int
   hello_worlds n
#+END_SRC

**** List replication
#+BEGIN_SRC haskell
f n = concat . map (replicate n)
main = do
   n <- readLn :: IO Int
   inputdata <- getContents
   mapM_ putStrLn $ map show $ f n $ map (read :: String -> Int) $ lines inputdata
#+END_SRC
**** Filter Array
#+BEGIN_SRC haskell
f :: Int -> [Int] -> [Int]
f _ [] = [] 
f n (x:xs)
    | (x < n) = (x:(f n xs))
    | otherwise = f n xs

main = do 
    n <- readLn :: IO Int 
    inputdata <- getContents 
    let 
        numbers = map read (lines inputdata) :: [Int] 
    putStrLn . unlines $ (map show . f n) numbers
#+END_SRC
**** Filter Positions in a list
#+BEGIN_SRC haskell
f :: [Int] -> [Int]
f (x:xs) = g xs
f [] = []

g :: [Int] -> [Int]
g (x:xs) = x : (f xs)
g [] = []

main = do
   inputdata <- getContents
   mapM_ (putStrLn. show). f. map read. lines $ inputdata
#+END_SRC
**** Array of N elements
#+BEGIN_SRC haskell
fn n = [1..n]
#+END_SRC
**** Reverse a list
#+BEGIN_SRC haskell
  rev [] = []
  rev (x:xs) = (rev xs) ++ [x]

  main = do
    inputdata <- getContents
    mapM_ putStrLn $ map show $ rev $ map (read :: String -> Int) $ lines inputdata
#+END_SRC
**** Sum of Odd elements
#+BEGIN_SRC haskell
isOdd x = (mod x 2 == 1)
f = sum . (filter (isOdd))

main = do
   inputdata <- getContents
   putStrLn $ show $ f $ map (read :: String -> Int) $ lines inputdata
#+END_SRC
**** List Length
#+BEGIN_SRC haskell
  len :: [a] -> Int
  len lst = case lst of
              []     -> 0
              (x:xs) -> succ (len xs)

  main = do
    inputdata <- getContents
    putStrLn $ show $ len $ map (read :: String -> Int) $ lines inputdata
#+END_SRC
**** Update List
#+BEGIN_SRC haskell
f = map abs
main = do
   inputdata <- getContents
   mapM_ putStrLn $ map show $ f $ map (read :: String -> Int) $ lines inputdata
#+END_SRC
**** Evaluating e^x
#+BEGIN_SRC haskell
import Control.Applicative
import Control.Monad
import System.IO

main :: IO ()
main = do
    n_temp <- getLine
    let n = read n_temp :: Int
    forM_ [1..n] $ \a0  -> do
        x_temp <- getLine
        let x = read x_temp :: Double

getMultipleLines :: Int -> IO [String]
getMultipleLines n
    | n <= 0 = return []
    | otherwise = do          
        x <- getLine         
        xs <- getMultipleLines (n-1)    
        let ret = (x:xs)    
        return ret 
#+END_SRC
**** Functions or not?
#+BEGIN_SRC haskell
import Control.Monad
import Data.Char

allDifferent :: (Eq a) => [a] -> Bool
allDifferent [] = True
allDifferent (x:xs) = (notElem x xs) && (allDifferent xs)

isFunction :: (Eq a) => [(a,a)] -> Bool
isFunction l = allDifferent (map fst l)

main :: IO ()
main = do
  contents <- getContents
  let cases = parse contents
  let sols = map ((\x -> if x then "YES" else "NO") . isFunction) cases
  mapM_ putStrLn sols
  
parse :: String -> [[(Int,Int)]]
parse cnt = parseHead $ drop 1 (lines cnt)

parseHead :: [String] -> [[(Int,Int)]]
parseHead [] = []
parseHead (x:xs) = parseBody (take n xs) : parseHead (drop n xs)
  where n = read x

parseBody :: [String] -> [(Int,Int)]
parseBody = map ((\[a,b] -> (a,b)) . (map read) . words)
#+END_SRC
**** Compute the perimeter of a polygon
#+BEGIN_SRC haskell
perimeter :: [(Int,Int)] -> Float
perimeter l = sum $ map distance (pairs l)

pairs :: [a] -> [(a,a)]
pairs l = zip l (tail l ++ [head l])

distance :: ((Int,Int),(Int,Int)) -> Float
distance ((x,y),(v,w)) = sqrt . fromIntegral $ (x-v)^2 + (y-w)^2

main :: IO ()
main = do
  contents <- getContents
  let points = parseContents contents
  let perim = perimeter points
  print perim

parseContents :: String -> [(Int,Int)]
parseContents str = map ((\[a,b] -> (a,b)) . (map read) . words) (take (read n) ns)
  where n:ns = lines str
#+END_SRC
**** Compute the area of a polygon
#+BEGIN_SRC haskell
area :: [(Int,Int)] -> Float
area l = (fromIntegral (sum $ map (\((x,y),(v,w)) -> (x*w-y*v)) (pairs l))) * 0.5

pairs :: [a] -> [(a,a)]
pairs l = zip l (tail l ++ [head l])

main :: IO ()
main = do
  contents <- getContents
  let points = parseContents contents
  print $ (area points)

parseContents :: String -> [(Int,Int)]
parseContents str = map ((\[a,b] -> (a,b)) . (map read) . words) (take (read n) ns)
  where n:ns = lines str
#+END_SRC
*** Recursion
**** Computing the GCD
#+BEGIN_SRC haskell
module Main where

gcd' :: Integral a => a -> a -> a
gcd' a b
    | (b < a) = gcd'' a b
    | otherwise = gcd'' b a
    where
        gcd'' x 0 = x
        gcd'' x y = gcd'' y (rem x y)

main = do
  input <- getLine
  print . uncurry gcd' . listToTuple . convertToInt . words $ input
 where
  listToTuple (x:xs:_) = (x,xs)
  convertToInt = map (read :: String -> Int)
#+END_SRC
**** Fibonacci numbers
#+BEGIN_SRC haskell
module Main where

fib :: Int -> Int
fib n
    | (n==1) = 0
    | (n==2) = 1
    | otherwise = (fib (n-1)) + (fib (n-2))

main = do
    input <- getLine
    print . fib . (read :: String -> Int) $ input
#+END_SRC
**** Pascal's triangle
#+BEGIN_SRC haskell
factorial :: Int -> Int
factorial 0 = 1
factorial n = n * (factorial (n-1))

binomial :: Int -> Int -> Int
binomial n r = quot (factorial n) ((factorial r) * (factorial (n-r)))

pascal :: Int -> [[Int]]
pascal n = map pascalfile [0..(n-1)]
  where
    pascalfile m = map (binomial m) [0..m]

main :: IO ()
main = do
  x <- getLine
  let n = read x :: Int
  let list = pascal n
  mapM_ putStrLn (map (unwords . (map show)) list)
  return ()
#+END_SRC
**** String-o-Permute
#+BEGIN_SRC haskell
import Control.Monad

permute :: String -> String
permute []       = []
permute (a:b:xs) = b:a:(permute xs)

main :: IO ()
main = do
  n <- readLn
  replicateM_ n (do
                    s <- getLine
                    putStrLn $ permute s
                )
#+END_SRC
**** String Compression
#+BEGIN_SRC haskell
compress :: String -> String
compress = compressacc (0,'0')
  where
    compressacc :: (Int,Char) -> String -> String
    compressacc (n,x) []
      | n == 0    = []
      | n == 1    = [x]
      | otherwise = x : show n
    compressacc (n,x) (y:ys)
      | x == y    = compressacc (succ n,x) ys
      | otherwise = compressacc (n,x) [] ++ compressacc (1,y) ys
  
main :: IO ()
main = do
  string <- getLine
  putStrLn $ compress string
#+END_SRC
**** Prefix Compression
#+BEGIN_SRC haskell
compression :: String -> String -> (String,String,String)
compression [] y = ([],[],y)
compression x [] = ([],x,[])
compression (x:xs) (y:ys)
    | x == y    = (x:a,b,c) 
    | otherwise = ([],x:xs,y:ys)
  where (a,b,c) = compression xs ys

linelen :: String -> String
linelen x = show (length x) ++ " " ++ x

main = do x <- getLine
          y <- getLine
          let (a,b,c) = compression x y
          putStrLn $ linelen a
          putStrLn $ linelen b
          putStrLn $ linelen c
#+END_SRC
**** String Reductions
#+BEGIN_SRC haskell
reduction :: Eq a => [a] -> [a]
reduction []    = []
reduction (x:xs)
    | elem x xs = reduction xs
    | otherwise = x:(reduction xs)

main :: IO ()
main = do x <- getLine
          putStr $ reverse (reduction (reverse x))
#+END_SRC
**** The Sums of Powers
#+BEGIN_SRC haskell
forms :: [Int] -> Int -> Int
forms _  0 = 1
forms [] _ = 0
forms (x:xs) g
  | g < x     = 0
  | otherwise = (forms xs g) + (forms xs (g-x))

sumpowers :: Int -> Int -> Int
sumpowers n e = forms (map (^e) [1..]) n

main :: IO ()
main = do
  n <- readLn :: IO Int
  e <- readLn :: IO Int
  putStrLn . show $ sumpowers n e
#+END_SRC
**** Super-Queens on a chessboard
#+BEGIN_SRC haskell
import Control.Monad
import Control.Applicative ((<$>))
import Data.Sequence as Seq

attack :: (Int,Int) -> (Int,Int) -> Bool
attack (xa,ya) (xb,yb)
  | ((abs (xa-xb) <= 2) && (abs (ya-yb) <= 2)) = True
  | (abs (xa-xb)) == (abs (ya-yb)) = True
  | otherwise = False

putQueen :: Int -> [(Int,Int)] -> Seq Bool -> Int -> Int
putQueen n prevqueens columns row = if n == row then 1 else sum $ do
  c <- [0..(n-1)]
  guard $ not $ index columns c
  guard $ not $ any (attack (row,c)) prevqueens
  return $ putQueen n ((row,c):prevqueens) (update c True columns) (succ row)

queens :: Int -> Int
queens n = putQueen n [] (Seq.replicate n False) 0

main :: IO ()
main = queens <$> readLn >>= print
#+END_SRC
**** Sequence full of colors
#+BEGIN_SRC haskell
import Control.Monad

fullcolorrec :: Int -> Int -> String -> Bool
fullcolorrec rg yb []       = (rg == 0) && (yb == 0)
fullcolorrec rg yb ('R':xs) = (rg <  1) && (fullcolorrec (rg+1) yb xs)
fullcolorrec rg yb ('G':xs) = (rg > -1) && (fullcolorrec (rg-1) yb xs)
fullcolorrec rg yb ('Y':xs) = (yb <  1) && (fullcolorrec rg (yb+1) xs)
fullcolorrec rg yb ('B':xs) = (yb > -1) && (fullcolorrec rg (yb-1) xs)


fullcolor :: String -> Bool
fullcolor = fullcolorrec 0 0 

main :: IO ()
main = do
  cases <- readLn
  replicateM_ cases (
    do
      chain <- getLine
      putStrLn . show $ fullcolor chain
    )
#+END_SRC
**** Filter Elements
#+BEGIN_SRC haskell
import Data.Map 
import Data.List
import Control.Monad

-- Counter
type Counter = Map Int Int

toCounter :: [Int] -> Counter
toCounter = Prelude.foldl add empty

add :: Counter -> Int -> Counter
add l x = insertWith (+) x 1 l
  

-- Filter
filterk :: [Int] -> Int -> [Int]
filterk l k = Data.List.nub $ Data.List.filter ((flip elem) (keys $ Data.Map.filter (>=k) (toCounter l))) l

showFilter :: [Int] -> String
showFilter [] = "-1"
showFilter xs = intercalate " " $ Data.List.map show xs

main = do
  cases <- readLn
  replicateM_ cases (
    do
      (n,k) <- fmap (\[a,b] -> (a,b)) $ fmap ((Data.List.map read) . words) getLine
      list <- fmap ((Data.List.map read) . words) getLine
      let filteredlist = filterk list k
      putStrLn $ showFilter filteredlist
    )
#+END_SRC
*** Functional Structures
**** Valid BST
#+BEGIN_SRC haskell
import Control.Monad

data BinTree a = Empty
               | Node a (BinTree a) (BinTree a)

insert :: (Ord a) => BinTree a -> a -> BinTree a
insert Empty x = Node x Empty Empty
insert (Node n lt rt) x
       | x > n = Node n lt (insert rt x)
       | x < n = Node n (insert lt x) rt

preorder :: BinTree a -> [a]
preorder Empty = []
preorder (Node n lt rt) = [n] ++ preorder lt ++ preorder rt

main :: IO ()
main = do cases <- readLn :: IO Int
          replicateM_ cases handleCase

handleCase :: IO ()
handleCase = do n <- readLn :: IO Int
                s <- getLine
                -- Reads tree
                let list = map read $ (words s) :: [Int]
                let tree = foldl insert Empty list
                let nlist = preorder tree
                -- Compares
                case (list == nlist) of
                  True -> putStrLn "YES"
                  False -> putStrLn "NO"
#+END_SRC
**** Lists and GCD
#+BEGIN_SRC haskell
  import Control.Monad
  import Data.List (intercalate)

  gcdlist :: [[(Int,Int)]] -> [(Int,Int)]
  gcdlist xs = foldr gcdtwo (head xs) xs

  gcdtwo :: [(Int,Int)] -> [(Int,Int)] -> [(Int,Int)]
  gcdtwo [] _  = []
  gcdtwo _  [] = []
  gcdtwo ((x,n):xs) ((y,m):ys)
    | (x == y) = (x, min n m):(gcdtwo xs ys)
    | (x <  y) = gcdtwo xs ((y,m):ys)
    | (x >  y) = gcdtwo ((x,n):xs) ys

  pairs :: [a] -> [(a,a)]
  pairs []       = []
  pairs (x:y:xs) = (x,y):(pairs xs)

  showPair :: (Show a) => (a,a) -> String
  showPair (x,y) = (show x) ++ " " ++ (show y) 

  main :: IO ()
  main = do
    cases <- readLn :: IO Int
    lists <- replicateM cases (fmap (pairs . (map read) . words) getLine)
    putStrLn $ intercalate " " $ map showPair $ gcdlist lists
#+END_SRC
**** Tree Manager
#+BEGIN_SRC haskell
import Control.Monad
import Control.Monad.Writer
import Data.Sequence (Seq, singleton)
import Data.Foldable (sequence_)

data Tree a = Node a [Tree a]
data Trail a = Trail (a, [Tree a], [Tree a])
type ZipTree a = (Tree a, [Trail a])

change :: a -> ZipTree a -> ZipTree a
change x (Node y xs, t) = (Node x xs, t)

get :: ZipTree a -> a
get (Node x xs, t) = x

visitLeft :: ZipTree a -> ZipTree a
visitLeft (t, Trail (p, l:ls, rs) : ts) = (l, Trail (p, ls, t:rs) : ts)

visitRight :: ZipTree a -> ZipTree a
visitRight (t, Trail (p, ls, r:rs) : ts) = (r, Trail (p, t:ls, rs) : ts)

visitParent :: ZipTree a -> ZipTree a
visitParent (t, Trail (p, ls, rs) : ts) = (Node p ((reverse ls) ++ [t] ++ rs), ts)

visitChild :: Int -> ZipTree a -> ZipTree a
visitChild n (Node y (x:xs), p) = rightntimes (x, (Trail (y, [], xs)):p)
  where
    rightntimes = (foldr (.) id (replicate (n-1) visitRight))

insertLeft :: a -> ZipTree a -> ZipTree a
insertLeft  l (t, Trail (p, ls, rs) : ts) = (t, Trail (p, (Node l []):ls, rs) : ts)

insertRight :: a -> ZipTree a -> ZipTree a
insertRight r (t, Trail (p, ls, rs) : ts) = (t, Trail (p, ls, (Node r []):rs) : ts)

insertChild :: a -> ZipTree a -> ZipTree a
insertChild c (Node x xs, ts) = (Node x ((Node c []):xs), ts)

delete :: ZipTree a -> ZipTree a
delete (_, Trail (p, ls, rs) : ts) = (Node p ((reverse ls) ++ rs), ts)

printTree :: (Show a) => ZipTree a -> Writer (Seq String) (ZipTree a)
printTree zt@(Node x _,_) = writer (zt, singleton (show x))

readOperation :: (Read a, Show a) => [String] -> (ZipTree a -> Writer (Seq String) (ZipTree a))
readOperation s = case s of
  ["change", x]         -> fmap return $ change (read x)
  ["print"]             -> printTree
  ["visit","left"]      -> fmap return $ visitLeft
  ["visit","right"]     -> fmap return $ visitRight
  ["visit","parent"]    -> fmap return $ visitParent
  ["visit","child", n]  -> fmap return $ visitChild (read n)
  ["insert","left", x]  -> fmap return $ insertLeft (read x)
  ["insert","right", x] -> fmap return $ insertRight (read x)
  ["insert","child", x] -> fmap return $ insertChild (read x)
  ["delete"]            -> fmap return $ delete
  _                     -> error "Invalid expression"

startTree :: ZipTree Int
startTree = (Node 0 [], [])


main = do
  n <- readLn :: IO Int
  operations <- replicateM n (fmap (readOperation . words) getLine)
  let (a,w) = runWriter $ foldl (>>=) (return startTree) operations
  Data.Foldable.sequence_ $ fmap putStrLn w
#+END_SRC
**** Fighting Armies
#+BEGIN_SRC haskell
import Data.Sequence as Seq
import Data.Foldable
import Data.Vector.Mutable as Vect (replicate,unsafeRead,unsafeWrite,modify,unsafeModify,MVector)
import Control.Monad
import Control.Monad.Primitive
import qualified Data.ByteString.Lazy.Char8 as DB

data BinomialTree a = Nil | Node a (Seq (BinomialTree a))
  deriving (Show)
type BinomialHeap a = [BinomialTree a]

singleton :: a -> BinomialTree a
singleton x = Node x empty

singleHeap :: a -> BinomialHeap a
singleHeap x = [Main.singleton x]

sumTree :: (Ord a) => BinomialTree a -> BinomialTree a -> (BinomialTree a, BinomialTree a)
sumTree x   Nil = (x,Nil)
sumTree Nil y   = (y,Nil)
sumTree (Node x xs) (Node y ys)
  | x >= y    = (Nil,Node x (xs |> Node y ys))
  | otherwise = (Nil,Node y (ys |> Node x xs))

sumTrees :: (Ord a) => BinomialTree a
         -> BinomialTree a
         -> BinomialTree a
         -> (BinomialTree a, BinomialTree a)
sumTrees t x Nil = sumTree t x
sumTrees t Nil y = sumTree t y
sumTrees Nil x y = sumTree x y
sumTrees t x y   = (txy,rr)
  where (xy,r)   = sumTree x y
        (txy,rt) = sumTree xy t
        (rr,_)   = sumTree r rt

sumHeaps :: (Ord a) => BinomialTree a -> BinomialHeap a -> BinomialHeap a -> BinomialHeap a
sumHeaps Nil [] []     = []
sumHeaps Nil [x] (Nil:ys) = x:ys
sumHeaps Nil (x:xs) [] = x:xs
sumHeaps Nil [] (y:ys) = y:ys
sumHeaps t []     []     = [t]
sumHeaps t (x:xs) []     = tx:sumHeaps r xs []
  where (tx, r) = sumTree t x
sumHeaps t []     (y:ys) = ty:sumHeaps r [] ys
  where (ty, r) = sumTree t y
sumHeaps t (x:xs) (y:ys) = txy:sumHeaps r xs ys
  where (txy, r) = sumTrees t x y




merge :: (Ord a) => BinomialHeap a -> BinomialHeap a -> BinomialHeap a
merge = sumHeaps Nil

insert :: (Ord a) => a -> BinomialHeap a -> BinomialHeap a
insert x = merge (singleHeap x)

findMin :: BinomialHeap Int -> Int
findMin h = Prelude.foldr max 0 $ fs h
  where
    fs []            = []
    fs (Nil:xs)      = fs xs
    fs (Node x _:xs) = x:fs xs

deleteMinTree :: (Ord a) => a -> BinomialHeap a -> (BinomialHeap a, BinomialHeap a)
deleteMinTree _ []               = ([],[])
deleteMinTree m (Nil:xs)         = (Nil:fst (deleteMinTree m xs),snd $ deleteMinTree m xs)
deleteMinTree m (Node x ts:xs)
  | x == m    = (Nil:fst (deleteMinTree m xs), toList ts)
  | otherwise = (Node x ts:fst (deleteMinTree m xs), snd $ deleteMinTree m xs)

deleteMin :: BinomialHeap Int -> BinomialHeap Int
deleteMin h = merge hm mint
  where (hm, mint) = deleteMinTree (findMin h) h




main :: IO ()
main = do
  [narmies, _] <- fmap (map read . words) getLine :: IO [Int]
  army <- Vect.replicate (succ narmies) []
  contents <- fmap DB.lines DB.getContents
  Control.Monad.forM_ contents (\line ->
    do
      let order = map readbs . DB.words $ line
      case order of
        [1,i] -> do
          arm <- Vect.unsafeRead army i
          print $ findMin arm
        [2,i] ->
          Vect.unsafeModify army deleteMin i
        [3,i,c] ->
          Vect.unsafeModify army (insert c) i
        [4,i,j] -> do
          armj <- Vect.unsafeRead army j
          Vect.unsafeModify army (merge armj) i
    )
  return ()

readbs :: DB.ByteString -> Int
readbs n = case DB.readInt n of
  Nothing -> undefined
  Just (m,_) -> m
#+END_SRC
*** Memoization and DP
**** Number of Binary Search Tree
#+BEGIN_SRC haskell
import Control.Monad

(*.),(+.) :: Int -> Int -> Int
(*.) = (\a b -> (a*b) `mod` 100000007)
(+.) = (\a b -> (a+b) `mod` 100000007)

bin :: [Int]
bin = 1 : do
  n <- [1..]
  return $ foldr (+.) 0 $ do
    c <- [0..(n-1)]
    return $ (bin !! c) *. (bin !! (n-1-c))

main :: IO ()
main = do
  cases <- readLn :: IO Int
  replicateM_ cases (
    do
      n <- readLn
      print $ bin !! n
    )
#+END_SRC
**** Pentagonal Numbers
#+BEGIN_SRC haskell
import Control.Monad

pentagonals = 0 : zipWith (+) pentagonals (map ((+1) . (*3)) [0..])
pentagonal n = quot (n*(3*n-1)) 2

main = do
  n <- readLn
  replicateM_ n (
    do
      m <- readLn
      print $ pentagonal m
    )
#+END_SRC
**** Fibonacci
#+BEGIN_SRC haskell
import Control.Monad

modulo = 100000000 + 7
(+.) = \x -> \y -> mod (x+y) modulo
fibonacci = [0,1] ++ (zipWith (+.) fibonacci (tail fibonacci))
fib = (fibonacci !!)

main = do
  cases <- readLn
  replicateM_ cases (do
                        n <- readLn
                        print $ fib n
                    )
#+END_SRC
**** Expressions
#+BEGIN_SRC haskell
import Control.Monad
import Data.Sequence (Seq,singleton)
import Data.Foldable (toList)
import Data.Monoid

(+.) a b = mod (a+b) 101
(*.) a b = mod (a*b) 101
(-.) a b = mod (a-b) 101

operation :: (Int,Seq String) -> Int -> [(Int,Seq String)]
operation (n,s) x = [ (n *. x,mappend s $ singleton ("*"++show x)),
                      (n -. x,mappend s $ singleton ("-"++show x)),
                      (n +. x,mappend s $ singleton ("+"++show x))
                    ]

solution :: [Int] -> String
solution (x:xs) = concat . toList $
  snd . head $ filter ((==0) . fst) $ foldM operation (x,singleton (show x)) xs

main :: IO ()
main = do
  n <- readLn :: (IO Int)
  nms <- fmap ((fmap read) . words) getLine :: (IO [Int])
  putStrLn $ solution nms
#+END_SRC
*** Ad Hoc
**** Jumping Bunnies
#+BEGIN_SRC haskell
import Control.Monad

jumps :: (Integral a) => [a] -> a
jumps = foldr lcm 1

main :: IO ()
main = do
  n <- readLn :: IO Int
  bunnies <- (fmap ((map read) . words) getLine) :: IO [Int]
  print $ jumps bunnies
#+END_SRC
**** Rotate String
#+BEGIN_SRC haskell
import Data.List

rotations :: String -> [String]
rotations s = tail $ zipWith (++) (tails s) (inits s)

main = do
  strings <- input
  let output = map ((intercalate " ") . rotations) strings
  mapM_ putStrLn output
  
input :: IO [String]
input = do
  n <- readLn :: IO Int
  sequence $ map (\i -> getLine) [1..n]
#+END_SRC
**** Remove Duplicates
#+BEGIN_SRC haskell
import Data.Char
import Data.Bits

type Bit32 = Int

indexChar :: Char -> Int
indexChar c = (ord c) - (ord 'a')

isChar :: Bit32 -> Char -> Bool
isChar a c = testBit a (indexChar c)

setChar :: Bit32 -> Char -> Bit32
setChar a c = setBit a (indexChar c)


duplicates :: String -> String
duplicates xs = duplicates' 0 xs

duplicates' :: Bit32 -> String -> String
duplicates' _ []     = []
duplicates' b (x:xs)
  | (isChar b x)  = duplicates' b xs
  | otherwise     = x : (duplicates' (setChar b x) xs)

main = do
  string <- getLine
  putStrLn (duplicates string)
#+END_SRC
**** Huge GCD
#+BEGIN_SRC haskell
(*.) a b = mod (a*b) 1000000007

hugegcd :: [Int] -> [Int] -> Int
hugegcd as bs = fst $ foldr gcdr (1,bs) as
  where
    gcdr :: Int -> (Int,[Int]) -> (Int,[Int])
    gcdr a (g,br) = (g *. ng, nbr)
      where
        (ng,nbr) = gcda a br

gcda :: Int -> [Int] -> (Int,[Int])
gcda a []     = (1,[])
gcda a (b:bs) = (d *. g, (quot b d):ls)
  where
    d      = gcd a b
    (g,ls) = gcda (quot a d) bs


main = do
  a <- readLn :: IO Int
  lista <- fmap ((map read) . words) getLine
  b <- readLn :: IO Int
  listb <- fmap ((map read) . words) getLine
  putStrLn . show $ hugegcd lista listb
#+END_SRC
**** Missing Numbers (FP)
#+BEGIN_SRC haskell
import Prelude hiding (replicate, zipWith)
import Data.List hiding (replicate, zipWith)
import Data.Sequence

counter :: [Int] -> Seq Int
counter = foldr (adjust (+1)) (replicate 110 0) 

difference :: [Int] -> [Int] -> [Int]
difference as bs = map (+minb) $ findIndicesL (>0) $ zipWith (-) (counter bms) (counter ams)
  where
    minb = minimum bs
    ams  = map ((flip (-)) minb) as
    bms  = map ((flip (-)) minb) bs 

main :: IO ()
main = do
  na <- readLn :: IO Int
  anumbers <- fmap (map read . words) getLine
  nb <- readLn :: IO Int
  bnumbers <- fmap (map read . words) getLine
  putStrLn . (intercalate " ") . (map show) $ difference anumbers bnumbers
#+END_SRC
**** Common divisors
#+BEGIN_SRC haskell
import Data.List
import Control.Monad
import Control.Arrow

factors :: Int -> [Int]
factors n = fact 2 n
  where
    fact d n
      | d > n          = []
      | (mod n d == 0) = d : fact d (quot n d)
      | otherwise      = fact (succ d) n

primefactors :: Int -> [(Int,Int)]
primefactors n = (map (head &&& length)) . group $ (factors n)

divisors :: Int -> Int
divisors n = product $ map ((+1) . snd) (primefactors n)

commondivisors :: Int -> Int -> Int
commondivisors x y = divisors $ gcd x y

main = do
  n <- readLn :: IO Int
  replicateM_ n (
    do
      (a,b) <- fmap ((\[x,y] -> (x,y)) . (map read) . words) getLine
      putStrLn . show $ commondivisors a b
    )
#+END_SRC
**** Captain Prime
#+BEGIN_SRC haskell
import Data.List

primes :: [Int]
primes = 2 : filter isPrime [3,5..]

isPrime :: Int -> Bool
isPrime x = (x>1) && (all (\n -> x `mod` n /= 0) $
            takeWhile (\n -> n * n <= x) primes)

leftReminders :: Int -> [Int]
leftReminders n = map read $ init $ tails (show n)

rightReminders :: Int -> [Int]
rightReminders 0 = []
rightReminders n = n : rightReminders (quot n 10)

haszero :: Int -> Bool
haszero n = elem '0' (show n)

fate :: Int -> String
fate n
  | haszero n     = "DEAD"
  | left && right = "CENTRAL"
  | left          = "LEFT"
  | right         = "RIGHT"
  | otherwise     = "DEAD"
  where
    left  = and (map isPrime $ leftReminders n)
    right = and (map isPrime $ rightReminders n)

main :: IO ()
main = do
  cases <- readLn 
  numbers <- mapM (\i -> readLn) [1..cases]
  let strings = map fate numbers
  mapM_ putStrLn strings
#+END_SRC
** Mathematics
*** Algebra
**** Easy sum
#+BEGIN_SRC haskell
import Control.Monad
import Control.Applicative
import Data.Bits

sumTo :: Int -> Int
sumTo k = (k*(k+1)) `shiftR` 1

easysum :: Int -> Int -> Int
easysum n m = (n `div` m) * (sumTo (m-1)) + (sumTo r)
    where r = n `mod` m

main :: IO ()
main = do
    cases <- readLn :: IO Int
    replicateM_ cases $ do
        [n,m] <- map read <$> words <$> getLine
        putStrLn $ show $ easysum n m
#+END_SRC
** Cracking the code interview
*** Data Structures
**** Arrays: Left Rotation
***** C++ version
#+BEGIN_SRC c++
  #include <vector>
  #include <iostream>
  using namespace std;

  vector<int> array_left_rotation(vector<int> a, int n, int k) {
      vector<int> result;
      for (int i=0; i<a.size(); i++)
          result.push_back(a[(i+k)%n]);
      return result;
  }

  int main(){
      int n;
      int k;
      cin >> n >> k;
      vector<int> a(n);
      for(int a_i = 0;a_i < n;a_i++){
          cin >> a[a_i];
      }
      vector<int> output = array_left_rotation(a, n, k);
      for(int i = 0; i < n;i++)
          cout << output[i] << " ";
      cout << endl;
      return 0;
  }
#+END_SRC

***** Haskell version
We are using a list in Haskell instead of an array.
Time complexity is the same, anyway. Using Data.Sequence
would not lead us to a better complexity.

#+BEGIN_SRC haskell
  import Control.Applicative
  import Data.List

  rotate :: Int -> [a] -> [a]
  rotate k xs = take (length xs) $ drop k (cycle xs)

  main :: IO ()
  main = do
    -- Input
    nt <- words <$> getLine
    let t = read $ nt!!1 :: Int
    larray <- (map read) . words <$> getLine
    -- Output
    let result = rotate t larray :: [Int]
    putStrLn (concat $ intersperse " " (map show result))
#+END_SRC

**** Strings: Making Anagrams
#+BEGIN_SRC cpp
  #include <vector>
  #include <cmath>
  #include <iostream>
  using namespace std;

  int number_needed(string a, string b) {
    vector<int> counting;
    for (int i=0; i<26; i++)
      counting.push_back(0);
    
    for (char c : a)
      counting[c-'a']++;
    for (char c : b)
      counting[c-'a']--;
    
    int sum = 0;
    for (int n : counting)
      sum += abs(n);
    
    return sum;
  }

  int main(){
    string a;
    cin >> a;
    string b;
    cin >> b;
    cout << number_needed(a, b) << endl;
    return 0;
  }
#+END_SRC
**** Hash Tables: Ransom Note
#+BEGIN_SRC cpp
  #include<vector>
  #include<iostream>
  #include<unordered_map>
  #include<string>
  using namespace std;

  int main() {
    bool answer = true;
    int mag_words;
    int ran_words;
    cin >> mag_words >> ran_words;

    unordered_map<string,int> magazine;
    for (int i=0; i<mag_words; i++) {
      string read;
      cin >> read;
      magazine.emplace(read,0);
      magazine[read]++;    
    }

    for (int i=0; i<ran_words and answer; i++) {
      string read;
      cin >> read;
      if (magazine.count(read) == 0 or magazine[read] == 0) {
        answer = false;
        break;
      }

      magazine[read]--;
    }


    if (answer)
      cout << "Yes";
    else
      cout << "No";
  }
#+END_SRC
**** Linked Lists: Detect a cycle
This solution uses two *fast and slow* pointers. The main idea
is that if you put two pointers into a cycle of length $n$ separated by a
distance of $a$ and move them, one at a speed of $1$ and the other at a 
speed of $2$; they will eventually collide after $a$ steps.

\[ a + n \equiv 2n \]
\[a \equiv n\]
\[\]
#+BEGIN_SRC c++
bool has_cycle(Node* head) {
    Node* slow = head;
    Node* fast = head;
    while ((slow != nullptr) and (fast != nullptr) and (fast->next != nullptr)) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast)
            return true;
    }
        
    return false;
}
#+END_SRC

**** Stacks: Balanced Brackets
#+BEGIN_SRC c++
  #include<iostream>
  #include<stack>
  using namespace std;

  bool is_balanced(string expression) {
    stack<char> brackets;
 
    for (char current : expression) {     
        if (current == '{' or current == '(' or current == '[')
            brackets.push(current);
        else if (not brackets.empty() and
                  (((current == '}') and (brackets.top() == '{')) or
                  ((current == ')') and (brackets.top() == '(')) or
                  ((current == ']') and (brackets.top() == '[')))
                )
                brackets.pop();
            else
                return false;
        }
   
    // It has to be empty!
    return brackets.empty();
  }

  int main(){
      int t;
      cin >> t;
      for(int a0 = 0; a0 < t; a0++){
          string expression;
          cin >> expression;
          bool answer = is_balanced(expression);
          if(answer)
              cout << "YES\n";
          else cout << "NO\n";
      }
      return 0;
  }
#+END_SRC
**** Queues: A tale of two stacks
#+BEGIN_SRC c++
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <stack>
#include <queue>
using namespace std;

class MyQueue {
  
    public:
        stack<int> stack_newest_on_top, stack_oldest_on_top;   
        void push(int x) {
            stack_newest_on_top.push(x);
        }

        void pop() {
            if (stack_oldest_on_top.empty())
                refill();
            stack_oldest_on_top.pop();
        }

        int front() {
            if (stack_oldest_on_top.empty())
                refill();
            return stack_oldest_on_top.top();
        }
    
        void refill() {
            while(not stack_newest_on_top.empty()) {
                stack_oldest_on_top.push(stack_newest_on_top.top());
                stack_newest_on_top.pop();
            }
        }
};

int main() {
    MyQueue q1;
    int q, type, x;
    cin >> q;
    
    for(int i = 0; i < q; i++) {
        cin >> type;
        if(type == 1) {
            cin >> x;
            q1.push(x);
        }
        else if(type == 2) {
            q1.pop();
        }
        else cout << q1.front() << endl;
    }

    return 0;
}
#+END_SRC
**** Trees: Is this a binary search tree?
#+BEGIN_SRC c++
  bool checkBST(Node* root) {
      return checkBSTBounds(root,-1,-1);
  }

  bool checkBSTBounds(Node* root, int lower, int upper) {
      if (!root)
          return true;
   
      int data = root->data;
      return ((upper == -1 or data < upper) and (lower == -1 or data > lower)) and
             checkBSTBounds(root->left, lower, data) and
             checkBSTBounds(root->right, data, upper);
  }
#+END_SRC
**** Heaps: Find the running median
#+BEGIN_SRC c++
  #include<vector>
  #include<algorithm>
  #include<iostream>
  #include<iomanip>

  using namespace std;

  int main() {
    cout << fixed << setprecision(1);
    vector<int> left_heap;
    vector<int> right_heap;
    float median;

    // Reads first case
    unsigned cases;
    cin >> cases;
    cin >> median;
    left_heap.push_back(median);
    push_heap(left_heap.begin(), left_heap.end(), greater<int>());
    cout << median << endl;

    for (unsigned i=1; i<cases; i++) {
      // Inserts new value
      int new_value; cin >> new_value;
      if (new_value > median) {
        right_heap.push_back(new_value);
        push_heap(right_heap.begin(), right_heap.end(), greater<int>());
      }
      else {
        left_heap.push_back(new_value);
        push_heap(left_heap.begin(), left_heap.end(), less<int>());
      }

      // Rebalances both heaps
      if (right_heap.size() > left_heap.size()) {
        int moving = right_heap[0];
        pop_heap(right_heap.begin(), right_heap.end(), greater<int>());
        right_heap.pop_back();

        left_heap.push_back(moving);
        push_heap(left_heap.begin(), left_heap.end(), less<int>());
      }
      if (left_heap.size() > right_heap.size()+1) {
        int moving = left_heap[0];
        pop_heap(left_heap.begin(), left_heap.end(), less<int>());
        left_heap.pop_back();

        right_heap.push_back(moving);
        push_heap(right_heap.begin(), right_heap.end(), greater<int>());
      }

      // Prints median
      if (i%2 != 0)
        median = (left_heap[0]+right_heap[0])/2.0;
      else
        median = left_heap[0];
      cout << median << endl;
    }
  }
#+END_SRC
**** Tries: Contacts
#+BEGIN_SRC c++
  #include<iostream>
  #include<string>
  #include<iomanip>
  using namespace std;

  struct trie {
    int counter;
    trie* children[26];
  };

  trie* create() {
    trie* t = new trie;
    t->counter = 0;
    for (int i=0; i<26; i++)
      t->children[i] = nullptr;
    return t;
  }


  void insert(trie* root, string s) {
    trie* current = root;
    for (char c : s) {
      trie* next = current -> children[c-'a'];
      if (next == nullptr) {
        trie* newtrie = create();
        current->children[c-'a'] = newtrie;
        current = newtrie;
      }
      else
        current = next; 
      current->counter++;
    }
  }


  int count(trie* root, string s) {
    trie* current = root;

    for (char c : s) {
      trie* next = current -> children[c-'a'];
      if (next == nullptr) {
        return 0;
      }
      else {
        current = next;
      }
    }

    return current -> counter;
  }


  int main() {
    trie* t = create();
    int cases; 
    cin >> cases;

    while(cases--) {
      string op, word;
      cin >> op >> word;
      if (op == "add")
        insert(t, word);
      else
        cout << count(t, word) << endl;     
    }
  }
#+END_SRC
*** Algorithms
**** Sorting: Bubble Sort
**** Sorting: Comparator
#+BEGIN_SRC python
  class Player:
      def __init__(self, name, score):
          self.name = name
          self.score = score
        
      def __repr__(self):
          pass
        
      def comparator(a, b):
          if (a.score == b.score):
              return cmp(a.name,b.name)
          else:
              return cmp(b.score,a.score)
#+END_SRC
**** Merge Sort: Counting Inversions
#+BEGIN_SRC cpp
  #include<vector>
  #include<iostream>
  using namespace std;
  typedef long long int lli;

  lli merge(vector<int>& array, int left, int right) {
    lli swaps = 0;
    int middle = (left+right)/2;
    vector<int> left_array(array.begin()+left, array.begin()+middle);
    vector<int> right_array(array.begin()+middle, array.begin()+right);

    int i = 0;
    int j = 0;
    int k = left;

    while (i < left_array.size() and j < right_array.size()) {
      if (left_array[i] <= right_array[j]) {
        array[k] = left_array[i];
        i++;
        k++;
      }
      else {
        array[k] = right_array[j];
        j++;
        k++;
        swaps += left_array.size()-i;
      }
    }


    while (i < left_array.size()) {
      array[k] = left_array[i];
      i++;
      k++;
    }

    while (j < right_array.size()) {
      array[k] = right_array[j];
      j++;
      k++;
    }

    return swaps;
  }


  lli mergesort(vector<int>& array, int left, int right) {
    if (right-left < 2)
      return 0;

    lli swaps = 0;
    int middle = (left+right)/2;
    swaps += mergesort(array, left, middle);
    swaps += mergesort(array, middle, right);
    swaps += merge(array, left, right);    

    return swaps;
  }


  int main() {
    int d; cin >> d;
    for (int cases=0; cases<d; cases++) {
      int n; cin >> n;
      vector<int> array(n);
      for (int i=0; i<n; i++)
        cin >> array[i];
      cout << mergesort(array,0,array.size()) << endl;
    }
  }
#+END_SRC
**** Binary Search: Ice Cream Parlor
#+BEGIN_SRC cpp
  #include <bits/stdc++.h>
  using namespace std;

  class IceCream {
    
  public: 
    int flavor; 
    int index;

    IceCream(int flavor, int index) {
      this->flavor = flavor;
      this->index = index;
    }
  };

  bool compare(IceCream a, IceCream b) {
    return a.flavor < b.flavor;
  }

  int binarySearch(int first, int last, vector<IceCream> arr, int search) {
    int middle = (first+last)/2;

    while (arr[middle].flavor != search) {
      if (first > last)
        return -1;
            
      if (arr[middle].flavor < search) {
        first = middle+1;
        middle = (first+last)/2;
      }
      else if (arr[middle].flavor > search) {
        last = middle-1;
        middle = (first+last)/2;
      }
    }
    
    return arr[middle].index;
  }

  int main() {
    int t;
    int n, m;
    cin >> t;
    for(int test = 0; test < t; test++) {       
      cin >> m >> n;
      vector<IceCream> arr;
      arr.reserve(n); 

      for (int i = 0; i < n; i++) {
        int cost;
        cin >> cost;
        arr.push_back(IceCream(cost, i + 1));
      }

      sort(arr.begin(), arr.end(), compare);
      int firstIndex = 100000, secondIndex = 100000;
      for(int i = 0; i < n - 1 ; i++) {
        int search = m - arr[i].flavor;
        if(search >= arr[i].flavor) {
          int index = binarySearch( i + 1, n - 1, arr, search);
          if( index != -1 ) {
            cout << min(arr[i].index, index) << " " << max(arr[i].index, index) << endl;
            break;

          }
        }
      }

    }

  }
#+END_SRC
**** DFS: Connected Cell in a Grid
#+BEGIN_SRC cpp
  #include<vector>
  #include<iostream>
  using namespace std;
  typedef vector<vector<bool> > Matrix;

  int count_region(Matrix& matrix, int i, int j) {
      matrix[i][j] = false;
      int sum = 1;
    
      for (int a = -1; a<2; a++)
          for (int b = -1; b<2; b++)
              if (i+a < matrix.size() and i+a >= 0)
                  if (j+a < matrix.size() and j+b >= 0)
                      if (matrix[i+a][j+b])
                          sum += count_region(matrix,i+a,j+b);

      return sum;
  }


  int larger_region(Matrix& matrix) {
      int max_region = 0;

      for (unsigned i=0; i<matrix.size(); i++) 
          for (unsigned j=0; j<matrix[i].size(); j++) 
              if (matrix[i][j]) {
                  int new_region = count_region(matrix,i,j);
                  if (new_region > max_region)
                      max_region = new_region;
              }

      return max_region;
  }


  int main() {
      Matrix matrix;
      int n,m;
      cin >> n; cin >> m;
      for (int i=0; i<n; i++) {
          vector<bool> row;
          for (int j=0; j<m; j++) {
              int read;
              cin >> read;
              row.push_back(read == 1);
          }
          matrix.push_back(row);
      }

      cout << larger_region(matrix);
  }
#+END_SRC
**** BFS: Shortest Reach
#+BEGIN_SRC cpp
  #include<vector>
  #include<queue>
  #include<iostream>
  using namespace std;
  typedef vector< vector<int> > Graph;

  int main() {
    int cases;
    cin >> cases;
    for (int k=0; k<cases; k++) {
      int nodes;
      int edges;
      cin >> nodes >> edges;
      Graph graph(nodes, vector<int>());
      vector<int> distance(nodes, -1);
      queue<int> to_visit;

      for (int i=0; i<edges; i++) {
        int a, b;
        cin >> a >> b;
        a = a-1;
        b = b-1;
        graph[a].push_back(b);
        graph[b].push_back(a);
      }

      int initial_node;
      cin >> initial_node;
      initial_node = initial_node-1;
      to_visit.push(initial_node);
      distance[initial_node] = 0;

      while (!to_visit.empty()) {
        int current = to_visit.front();
        to_visit.pop();
            
        for (int i=0; i<graph[current].size(); i++) {
          int next = graph[current][i];
          if (distance[next] == -1) {
            distance[next] = distance[current] + 6;
            to_visit.push(next);
          }
        }
      }

      for (int i=0; i<distance.size(); i++)
        if (i != initial_node)
          cout << distance[i] << " ";
      cout << endl;
    }
  }
#+END_SRC

*** Techniques
**** Time complexity: Primality
#+BEGIN_SRC c++
  #include<iostream>
  #include<cmath>
  using namespace std;

  int main() {
    int cases; cin >> cases;
    for (int i=0; i<cases; i++) {
      int input; cin >> input;
      bool is_prime = true;

      if (not (input > 1))
        is_prime = false;
    
      // Primality checker
      int root = (int) sqrt(input)+1;
      for (int i=2; i<root and is_prime; i++)
        is_prime = (input % i != 0);

      if (is_prime)
        cout << "Prime" << endl;
      else
        cout << "Not prime" << endl;
    }
  }
#+END_SRC
**** Recursion: Fibonacci numbers
We *won't use recursion* directly as I want to write a ${\cal O}(log(n))$ solution using matrices.
It uses bit manipulation in order to get the binary decomposition of the input.
#+BEGIN_SRC c++
  #include<vector>
  #include<iostream>
  using namespace std;

  typedef vector<int> Matrix;

  Matrix product(Matrix& a, Matrix& b) {
    Matrix prod;
    prod[0] = a[0]*b[0]+a[1]*b[2];
    prod[1] = a[0]*b[1]+a[1]*b[3];
    prod[2] = a[2]*b[0]+a[3]*b[2];
    prod[3] = a[2]*b[1]+a[3]*b[3];
    return prod;
  }

  int main() {
    int input; cin >> input;
    Matrix fib;
    fib.push_back(1);
    fib.push_back(1);
    fib.push_back(1);
    fib.push_back(0);
    Matrix result;
    result.push_back(1);
    result.push_back(0);
    result.push_back(0);
    result.push_back(1);

    while (input) {
      if (input & 1)
        result = product(result,fib);

      fib = product(fib,fib);
      input = (input >> 1);
    }

    cout << result[1] << endl;
  }
#+END_SRC
**** Recursion: Davis' Staircase
#+BEGIN_SRC cpp
  #include<vector>
  #include<iostream>
  using namespace std;
  vector<int> solutions;

  int ways_staircase(int staircase) {
    if (staircase < 0)
      return 0;
    if (staircase < solutions.size() and solutions[staircase] != -1)
      return solutions[staircase];

    int sum = 0;
    sum += ways_staircase(staircase-1);
    sum += ways_staircase(staircase-2);
    sum += ways_staircase(staircase-3);

    while (solutions.size() < staircase)
      solutions.push_back(-1);
    if (solutions.size() == staircase)
      solutions.push_back(staircase);
    if (staircase < solutions.size())
      solutions[staircase] = sum;
    
    return sum;
  }


  int main() {
    solutions.push_back(1);

    int cases; cin >> cases;
    for (int i=0; i<cases; i++) {
      int staircase;
      cin >> staircase;
      cout << ways_staircase(staircase) << endl;
    }
  }
#+END_SRC
**** DP: Coin Change
***** Naive approach
A naive solution using ${\cal O}(nm)$ space.

#+BEGIN_SRC cpp
  #include<vector>
  #include<iostream>
  using namespace std;
  typedef vector< vector<long long> > Matrix;
  typedef long long int lli;

  lli ways_change(Matrix& ways, vector<int>& coins, int dollars, int limit_coin) {
    if (dollars < 0)
      return 0;
    if (dollars == 0)
      return 1;
    if (limit_coin >= coins.size())
      return 0;

    if (ways[dollars][limit_coin] != -1)
      return ways[dollars][limit_coin];

    lli counter = 0;
    counter += ways_change(ways, coins, dollars-coins[limit_coin], limit_coin);
    counter += ways_change(ways, coins, dollars, limit_coin+1);
    
    ways[dollars][limit_coin] = counter;
    return counter;
  }


  int main() {
    int n;
    int m;
    cin >> n >> m;
    Matrix ways(n+1, vector<lli>(m,-1));
    vector<int> coins;

    for (int i=0; i<m; i++) {
      int read;
      cin >> read;
      coins.push_back(read);
    }

    cout << ways_change(ways,coins,n,0);
  }
#+END_SRC

***** Better solution
A better solution using ${\cal O}(n)$ space.

#+BEGIN_SRC cpp
  #include<vector>
  #include<iostream>
  using namespace std;
  typedef long long int lli;

  int main() {
    int n, m;
    cin >> n >> m;
    vector<int> coins(m);
    for (int i=0; i<m; i++)
      cin >> coins[i];

    vector<lli> ways(n+1,0);
    ways[0] = 1;

    for (int i=0; i < coins.size(); i++)
      for (int j=coins[i]; j < ways.size(); j++)
        ways[j] += ways[j-coins[i]];

    cout << ways[n];
  }
#+END_SRC
**** Bit manipulation: Lonely integer
Folds using =xor=. Every element will be cancelled out with its pair,
except for the result.

#+BEGIN_SRC c++
#include <vector>
#include <iostream>
using namespace std;

int lonely_integer(vector < int > a) {
    int result = 0;
    for (int i=0; i<a.size(); i++)
        result ^= a[i];
    return result;
}

int main(){
    int n;
    cin >> n;
    vector<int> a(n);
    for(int a_i = 0;a_i < n;a_i++){
       cin >> a[a_i];
    }
    cout << lonely_integer(a) << endl;
    return 0;
}
#+END_SRC
* Interview problems
** Google example interview
Taken from [[https://www.youtube.com/watch?v=XKu_SEDAykw][this youtube video]]:

#+BEGIN_SRC cpp
  bool HasPairWithSum (vector<int>& numbers, int sum) {
    unordered_set<int> complements;
  
    for (int n : numbers) {
      if (complements.find(n) != complements.end())
        return true;
      complements.add(sum-n);
    }

    return false;
  }
#+END_SRC
* Python Kung-fu
From the [[https://github.com/PythonGranada/python-kung-fu/][Python Kung-fu repository]].

** 0. String permutation
Using a vector as a sort of a hash, running in ${\cal O}(n)$.
#+BEGIN_SRC cpp :cmdline <<< 'asdf fsda'
  #include<vector>
  #include<string>
  #include<iostream>
  using namespace std;

  bool is_permutation(string a, string b) {
      vector<int> counter(26,0);
      for (char c : a)
          counter[c-'a']++;
      for (char c : b)
          counter[c-'a']--;

      for (int ocurrences : counter)
          if (ocurrences != 0)
              return false;

      return true;
  }

  int main() {
    string a,b;
    cin >> a >> b;
  
    // Checking that the two sizes are equal discards a lot of
    // edge cases.
    if (a.size() == b.size() and is_permutation(a,b))
      cout << "Permutation";
    else
      cout << "Not a permutation";
  }
#+END_SRC

#+RESULTS:
: Permutation

** 1. Unique characters
*** With a boolean vector
#+BEGIN_SRC cpp :cmdline <<< 'afsgdf'
  #include<vector>
  #include<iostream>
  #include<string>
  #include<stdint.h>
  using namespace std;

  bool unique_chars(string str) {
    if (str.size() > 26)
      return false;

    int32_t counter = 0;
    for (char c : str)
      if ((counter & (1 << (c-'a'))) != 0)
        return false;
      else
        counter |= (1 << (c-'a'));
    return true;
  }

  int main() {
    string str;
    cin >> str;

    if (unique_chars(str))
      cout << "Unique characters";
    else
      cout << "Repeated characters";
  }
#+END_SRC

#+RESULTS:
: Repeated characters

*** Without additional data structures
#+BEGIN_SRC cpp :cmdline <<< 'afsgdf'
  #include<vector>
  #include<algorithm>
  #include<iostream>
  using namespace std;

  bool unique_chars(string str) {
    if (str.size() > 26)
      return false;
    
    make_heap(str.begin(), str.end());
    sort_heap(str.begin(), str.end());
    for (int i=0; i<str.size()-1; i++)
      if (str[i] == str[i+1])
        return false;

    return true;
  }

  int main() {
    string str;
    cin >> str;

    if (unique_chars(str))
      cout << "Unique characters";
    else
      cout << "Repeated characters";
  }
#+END_SRC

#+RESULTS:
: Repeated characters
* Leetcode
** 31. Next permutation
#+BEGIN_SRC cpp
  class Solution {
  public:
      void nextPermutation(vector<int>& arr) {
          if (arr.size() == 0)
              return;

          // Find maximum sequence
          int end = arr.size()-1;
          while (end != 0 and arr[end]<=arr[end-1])
              end--;

          // Reverse the array
          int left = end;
          int right = arr.size()-1;
          while (left < right) {
              int swap = arr[left];
              arr[left] = arr[right];
              arr[right] = swap;
              left++;
              right--;
          }

          // Include next element
          if (end != 0) {
              int moving = end;
              while(arr[end-1] >= arr[moving])
                  moving++;
    
              int swap = arr[end-1];
              arr[end-1] = arr[moving];
              arr[moving] = swap;
          }
      }
  };
#+END_SRC
** DONE 33. Search in rotated sorted array
** 66. Plus One
#+BEGIN_SRC cpp
  class Solution {
  public:
      vector<int> plusOne(vector<int>& digits) {
          int position = digits.size()-1;
          digits[position]++;
        
          while (digits[position] > 9 and position > 0) {
              digits[position] %= 10;
              position--;
              digits[position]++;
          }
        
          if (digits[position] > 9) {
              digits[position] %= 10;
              digits.insert(digits.begin(), 1);
          }
        
          return digits;
      }
  };
#+END_SRC
** 74. Search a 2D matrix
#+BEGIN_SRC cpp
  class Solution {
  public:
      bool searchMatrix(vector<vector<int>>& matrix, int target) {
          int m = matrix.size();
          int n = matrix[0].size();
          int size = n*m;

          int left = 0;
          int right = size;
          while (left < right) {
              int middle = (left+right)/2;
              int attempt = matrix[middle/n][middle%n];

              if (target < attempt)
                  right = middle;
              else if (target > attempt)
                  left = middle+1;
              else
                  return true;
          }

          return false;
      }
  };
#+END_SRC
** DONE 84. Largest Rectangle in Histogram
** 92. Reversed Linked List II
#+BEGIN_SRC cpp
  /**
   ,* Definition for singly-linked list.
   ,* struct ListNode {
   ,*     int val;
   ,*     ListNode *next;
   ,*     ListNode(int x) : val(x), next(NULL) {}
   ,* };
   ,*/
  class Solution {
  public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {
      // Case m=n
      if (n == m)
        return head;
        
      // Case m=1
      if (m == 1) {
        ListNode* previous = nullptr;
        ListNode* current = head;
            
        for (int i=0; i<n-m+1; i++) {
          ListNode* following = current->next;
          current->next = previous;
          previous = current;
          current = following;
        }
            
        head->next = current;
        return previous;
      }
        
      // Case m>1
      ListNode* start = head;
      for (int i=0; i<m-2; i++)
        start = start->next;
      ListNode* posstart = start->next;
        
      ListNode* previous = nullptr;
      ListNode* current = posstart;
      for (int i=0; i<n-m+1; i++) {
        ListNode* following = current->next;
        current->next = previous;
        previous = current;
        current = following;
      }
        
      start->next = previous;
      posstart->next = current;
        
      return head;
    }
  };
#+END_SRC
** 101. Symmetric tree
*** Recursive solution
#+BEGIN_SRC cpp
  class Solution {
  public:
    bool equalToMirror(TreeNode* a, TreeNode* b) {
      if (a == nullptr or b == nullptr)
	return (a == b);
      return a->val == b->val and equalToMirror(a->left, b->right) and equalToMirror(a->right,b->left);
    }

    bool isSymmetric(TreeNode* root) {
      if (root == nullptr)
	return true;
      return equalToMirror(root->left, root->right);
    }
  };
#+END_SRC
*** Iterative solution: BFS
#+BEGIN_SRC cpp
  class Solution {
  public:
    bool isSymmetric(TreeNode* root) {
      if (root == nullptr)
	return true;

      queue<TreeNode*> lhq;
      queue<TreeNode*> rhq;
      lhq.push(root->left);
      rhq.push(root->right);

      while (!lhq.empty() and !rhq.empty()) {
	TreeNode* fl = lhq.front();
	TreeNode* fr = rhq.front();
	lhq.pop();
	rhq.pop();

	if (fr == nullptr and fl == nullptr)
	  continue;
	if (fl == nullptr or fr == nullptr)
	  return false;
	if (fl->val != fr->val)
	  return false;

	lhq.push(fl->left);
	rhq.push(fr->right);
	lhq.push(fl->right);
	rhq.push(fr->left);
      }


      return (lhq.empty() and rhq.empty());
    }
  };
#+END_SRC

*** Iterative solution: DFS
#+BEGIN_SRC cpp
  class Solution {
  public:
    bool isSymmetric(TreeNode* root) {
      if (root == nullptr)
	return true;

      stack<TreeNode*> lhq;
      stack<TreeNode*> rhq;
      lhq.push(root->left);
      rhq.push(root->right);
        
      while (!lhq.empty() and !rhq.empty()) {
	TreeNode* fl = lhq.top();
	TreeNode* fr = rhq.top();
	lhq.pop();
	rhq.pop();

	if (fl == nullptr and fr != nullptr)
	  return false;
	if (fr == nullptr and fl != nullptr)
	  return false;
	if (fr == nullptr and fl == nullptr)
	  continue;

	if (fl->val != fr->val)
	  return false;
            
	lhq.push(fl->left);
	rhq.push(fr->right);
	lhq.push(fl->right);
	rhq.push(fr->left);
      }

      return (lhq.empty() and rhq.empty());
    }
  };
#+END_SRC
** 113. Path Sum II
#+BEGIN_SRC cpp
  /**
   ,* Definition for a binary tree node.
   ,* struct TreeNode {
   ,*     int val;
   ,*     TreeNode *left;
   ,*     TreeNode *right;
   ,*     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
   ,* };
   ,*/
  class Solution {
  public:
    vector<vector<int>> pathSum(TreeNode* root, int sum) {
      vector<vector<int>> result;
      pathSumAcc(root,sum,result,vector<int>());
      return result;
    }

    void pathSumAcc(TreeNode* root, int sum, vector<vector<int>>& result, vector<int> acc) {
      if (root == nullptr) {
        if (sum == 0 and acc.size() != 0) 
          result.push_back(acc);
        return;
      }
        
      if (root->left == nullptr and root->right == nullptr)
        if (sum == root->val) {
          acc.push_back(root->val);
          result.push_back(acc);
          return;
        }    
        
      acc.push_back(root->val);
      if (root->right != nullptr) pathSumAcc(root->right, sum-root->val, result, acc);
      if (root->left != nullptr) pathSumAcc(root->left, sum-root->val, result, acc);
    }
  };
#+END_SRC
** 121. Best Time to Buy and Sell Stock
#+BEGIN_SRC cpp
  class Solution {
  public:
      int maxProfit(vector<int>& prices) {
          if (prices.size() == 0)
              return 0;
        
          int max = prices[0];
          int min = prices[0];
          int profit = 0;
        
          for (int p : prices) {
              if (p<min) {
                  min = p;
                  max = p;
              }
              if (p>max) {
                  max = p;
              }
            
              if (max-min > profit)
                  profit = max-min;
          }
        
          return profit;
      }
  };
#+END_SRC
** 133. Clone Graph
#+BEGIN_SRC cpp
  class Solution {
  private:
      unordered_map<int, UndirectedGraphNode*> cloned;
  public:
      UndirectedGraphNode* cloneGraph(UndirectedGraphNode* node) {
          if (node == nullptr)
              return nullptr;

          int label = node->label;

          if (cloned.find(label) != cloned.end()) 
              return cloned[label];

          UndirectedGraphNode* newnode = new UndirectedGraphNode(label);
          cloned[label] = newnode;
        
          for (UndirectedGraphNode* neighbor : node->neighbors)
              newnode->neighbors.push_back(cloneGraph(neighbor));
        
          return newnode;
    
      }
  };
#+END_SRC
** 136. Single number
#+BEGIN_SRC cpp
  class Solution {
  public:
    int singleNumber(vector<int>& nums) {
      int acc = 0;
      for (int n : nums)
	acc ^= n;
      return acc;
    }
  };
#+END_SRC
** 141. Linked list cycle
#+BEGIN_SRC cpp
  class Solution {
  public:
    bool hasCycle(ListNode *head) {
      ListNode* slow = head;
      ListNode* fast = head;
        
      while (fast != nullptr and fast->next != nullptr and slow != nullptr) {
	fast = fast->next->next;
	slow = slow->next;
	if (fast == slow)
	  return true;
      }
        
      return false;
    }
  };
#+END_SRC
** 153. Find Minimum in Rotated Sorted Array
#+BEGIN_SRC cpp
  class Solution {
  public:
    int findMin(vector<int>& nums) {
      if (nums.size() == 1)
        return nums[0];

      int pivot = nums[0];
      int i = 0;
      int j = nums.size()-1;

      if (nums[j] > pivot)
        return pivot;

      while (j > i+1) {
        int m = (i+j)/2;
        if (nums[m] > pivot)
          i = m;
        else
          j = m;
      }

      return nums[j];
    }
  };
#+END_SRC

** 169. Majority element
#+BEGIN_SRC cpp
  class Solution {
  public:
    int majorityElement(vector<int>& nums) {
      int counter = 0;
      int majority = 0;

      for (int n : nums)
        if (n == majority)
          counter++;
        else if (counter == 0) {
          majority = n;
          counter++;
        }
        else
          counter--;

      return majority;
    }
  };
#+END_SRC
** 187. Repeated DNA Sequences
#+BEGIN_SRC cpp
  class Solution {
  public:
      vector<string> findRepeatedDnaSequences(string s) {
          unordered_set<string> sequences;
          unordered_set<string> repeated;

          for (int i=9; i < s.size(); i++) {
              string sub = s.substr(i-9,10);
              if (sequences.find(sub) == sequences.end())
                  sequences.insert(sub);
              else
                 repeated.insert(sub);
          }
        
          vector<string> repeatedv(0,"");
          for (string st : repeated)
              repeatedv.push_back(st);
          return repeatedv;
      }
  };
#+END_SRC
** 191. Number of 1 bits
#+BEGIN_SRC cpp
  class Solution {
  public:
      int hammingWeight(uint32_t n) {
          int counter = 0;
          while (n != 0) {
              if (n & 1)
                  counter++;
              n >>= 1;
          }
          return counter;
      }
  };
#+END_SRC
** 203. Remove Linked list elements
#+BEGIN_SRC cpp
  class Solution {
  public:
    ListNode* removeElements(ListNode* head, int val) {
      ListNode* current = head;
      ListNode* previous = nullptr;
        
      while(current != nullptr) {
	if (current->val == val) {
	  if (previous != nullptr)
	    previous->next = current->next;
	  else
	    head = head->next;
	}
	else
	  previous = current;
	current = current->next;
      }
        
      return head;
    }
  };
#+END_SRC
** 215. Kth Largest Element in Array
#+BEGIN_SRC cpp
  class Solution {
  public:
      int select(vector<int>& nums, const int k, const int left, const int right) {
          const int pivot = nums[left];
          int i = left+1;
          int j = right;
        
          while (i <= j) {
              while (nums[i] < pivot)
                  i++;                
              while (nums[j] >= pivot and j>left)
                  j--;
              if (i < j) {
                  int swap = nums[i];
                  nums[i] = nums[j];
                  nums[j] = swap;
              }
          }

          // changes pivot
          nums[left] = nums[j];
          nums[j] = pivot;

          if (k < j)
              return select(nums, k, left, j-1);
          else if (k > j)
              return select(nums, k, j+1, right);
          else
              return pivot;
      }

      int findKthLargest(vector<int>& nums, int k) {
          return select(nums, nums.size()-k, 0, nums.size()-1);
      }
  };
#+END_SRC
** 219. Contains Duplicate II
#+BEGIN_SRC cpp
  class Solution {
  public:
      bool containsNearbyDuplicate(vector<int>& nums, int k) {
          unordered_set<int> nearby;
        
          for (int i=0; i<nums.size(); i++) {
              if (nearby.find(nums[i]) != nearby.end())
                  return true;
            
              nearby.insert(nums[i]);
            
              if (i>=k)
                  nearby.erase(nums[i-k]);
          }
        
          return false;
      }
  };
#+END_SRC
** 221. Maximal Square
#+BEGIN_SRC cpp
  class Solution {
  public:
    int access(vector<vector<int>>& matrix, int x, int y) {
      if (x < matrix.size() and x >= 0 and y >= 0 and y < matrix[x].size())
        return matrix[x][y];
      else
        return 0;
    }

    int triangle(int left, int right, int up, int down) {
      return (min(min(left,right),up) + 1) * down;
    }
    
    int maximalSquare(vector<vector<char>>& matrix) {
      // Transforms the matrix into an int matrix
      vector<vector<int>> imatrix;
      for (int i=0; i<matrix.size(); i++) {
        vector<int> row;
        for (int j=0; j<matrix[0].size(); j++)
          row.push_back(matrix[i][j]-'0');
        imatrix.push_back(row);
      }
        
      // Finds square
      int max = 0;
      for (int i=0; i<imatrix.size(); i++) {
        for (int j=0; j<imatrix[0].size(); j++) {
          imatrix[i][j] = triangle(access(imatrix, i-1, j), access(imatrix, i, j-1), access(imatrix,i-1,j-1), access(imatrix, i, j));
          cout << imatrix[i][j] << " ";
          if (max < imatrix[i][j])
            max = imatrix[i][j];
        }
        cout << endl;
      }
        
      return max*max;
    }   
  };
#+END_SRC

** 225. Implement Stack using Queues
#+BEGIN_SRC cpp
  class Stack {
  private:
    queue<int> in;
    
    void last_to_head() {
      for (int i=0; i<in.size()-1; i++) {
	in.push(in.front());
	in.pop();
      }
    }
    
  public:
    // Push element x onto stack.
    void push(int x) {
      in.push(x);
    }

    // Removes the element on top of the stack.
    void pop() {
      last_to_head();
      in.pop();
    }

    // Get the top element.
    int top() {
      last_to_head();
      int t = in.front();
      in.push(in.front());
      in.pop();
      return t;
    }

    // Return whether the stack is empty.
    bool empty() {
      return in.empty();
    }
  };
#+END_SRC
** 229. Majority Element II
#+BEGIN_SRC cpp
  class Solution {
  public:
    vector<int> majorityElement(vector<int>& nums) {
      int counter1 = 0;
      int counter2 = 0;
      int maj1 = 0;
      int maj2 = 0;
    
      // Looks for candidates
      for (int n : nums) {
        if (n == maj1)
          counter1++;
        else if (n == maj2)
          counter2++;
        else if (counter1 == 0) {
          maj1 = n;
          counter1++;
        }
        else if (counter2 == 0) {
          maj2 = n;
          counter2++;
        }
        else {
          counter1--;
          counter2--;
        }
      }

      // Checks the elements
      int checkcount1 = 0;
      int checkcount2 = 0;
      for (int n : nums) {
        if (n == maj1) checkcount1++;
        if (n == maj2) checkcount2++;
      }

      vector<int> solution;
      if (checkcount1 > nums.size()/3)
        solution.push_back(maj1);
      if (checkcount2 > nums.size()/3 and maj2 != maj1)
        solution.push_back(maj2);
      return solution;
    }
  };
#+END_SRC
** 232. Implement Queue using Stacks
#+BEGIN_SRC cpp
  class Queue {
  private:
      stack<int> in;
      stack<int> out;
  public:
      void refill() {
          while (!in.empty()) {
              out.push(in.top());
              in.pop();
          }
      }

      // Push element x to the back of queue.
      void push(int x) {
          in.push(x);
      }

      // Removes the element from in front of queue.
      void pop(void) {
          if (out.empty())
              refill();
          out.pop();
      }

      // Get the front element.
      int peek(void) {
          if (out.empty())
              refill();
          return out.top();
      }

      // Return whether the queue is empty.
      bool empty(void) {
          return (out.empty() and in.empty());
      }
  };
#+END_SRC
** 240. Search a 2D Matrix II
#+BEGIN_SRC cpp
  class Solution {
  public:
      bool searchMatrix(vector<vector<int>>& matrix, int target) {
          int m = matrix.size();
          int n = matrix[0].size();
          int size = n*m;
  
          int xp = m-1;
          int yp = 0;
  
          while (yp < n and xp >= 0) {
              if (matrix[xp][yp] < target)
                  yp++;
              else if (matrix[xp][yp] > target)
                  xp--;
              else
                  return true;
          }  
  
          return false;
      }
  };
#+END_SRC
** 326. Power of three
#+BEGIN_SRC cpp
  class Solution {
  public:
      bool isPowerOfThree(int n) {
          return n>0 && (n==1 || (n%3==0 && isPowerOfThree(n/3)));
      }
  };
#+END_SRC
** 343. Integer Break
Using the AM-GM inequality.
#+BEGIN_SRC cpp
  class Solution {
  public:
      int integerBreak(int n) {
          if (n == 1) return 1;
          if (n == 2) return 1;
          if (n == 3) return 2;
        
          int product = 1;
          if (n%3 == 1) {
              n -= 4; 
              product *= 4;
          }
          if (n%3 == 2) {
              n -= 2;
              product *= 2;
          }
        
          while (n > 0) {
              n -= 3;
              product *= 3;
          }
        
          return product;   
      }
  };
#+END_SRC
** 371. Sum of two integers
#+BEGIN_SRC cpp
  class Solution {
  public:
      int getSum(int a, int b) {
          if (b == 0)
              return a;
          return getSum(a ^ b, (a & b) << 1);
      }
  };
#+END_SRC
** 388. Counting Bits
#+BEGIN_SRC cpp
  class Solution {
  public:
      vector<int> countBits(int num) {
          vector<int> count(num+1,0);
      
          for (int i=1; i<num+1; i++)
              count[i] = count[i>>1] + (i&1);
      
          return count;
      }
  };
#+END_SRC
** 397. Integer Replacement
#+BEGIN_SRC cpp
  class Solution {
  public:
      int integerReplacement(int n) {
          if (n == 2147483647) return 32;
        
          int counter = 0;
        
          while (n > 3) {
              if (n & 1) {
                  if (n & 2)
                      n++;
                  else 
                      n--;
              }
              else 
                  n >>= 1;
              counter++;
          }
        
          if (n==3) return 2+counter;
          if (n==2) return 1+counter;
          return counter;
      }
  };
#+END_SRC
** DONE 412. Fizz Buzz
** DONE 441. Arranging Coins
** 445. Add two numbers
*** Reversing lists solution
#+BEGIN_SRC cpp
  /**
   ,* Definition for singly-linked list.
   ,* struct ListNode {
   ,*     int val;
   ,*     ListNode* next;
   ,*     ListNode(int x) : val(x), next(NULL) {}
   ,* };
   ,*/
  class Solution {
  private:
      ListNode* reverse(ListNode* head) {
          ListNode* previous = nullptr;
          ListNode* current = head;

          while (current != nullptr) {
              ListNode* following = current->next;
              current->next = previous;
              previous = current;
              current = following;
          }
        
          return previous;
      }
    
      ListNode* skipzeroes(ListNode* sum) {
          while (sum != nullptr and sum->val==0)
              sum = sum->next;
        
          if (sum == nullptr)
              sum = new ListNode(0);
            
          return sum;
      }


  public:
      ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
          l1 = reverse(l1);
          l2 = reverse(l2);
          ListNode* sum = new ListNode(0);
          ListNode* current = sum;

          while (l1 != nullptr or l2 != nullptr) {
              int l1val = (l1 == nullptr? 0 : l1->val);
              int l2val = (l2 == nullptr? 0 : l2->val);
              current->val += l1val+l2val;

              current->next = new ListNode(current->val > 9? 1 : 0);
              current->val %= 10;
              current = current->next;
              l1 = (l1 == nullptr? nullptr : l1->next);
              l2 = (l2 == nullptr? nullptr : l2->next);
          }
        
          sum = reverse(sum);
          sum = skipzeroes(sum);

          return sum;
      }
  };
#+END_SRC
** 453. Minimum moves to equal array elements
#+BEGIN_SRC cpp
  class Solution {
  public:
      int minMoves(vector<int>& nums) {
          int minimum = nums[0];
          for (int elem : nums)
              if (elem < minimum)
                  minimum = elem;
        
          int moves = 0;
          for (int elem : nums)
              moves += elem-minimum;
          return moves;
      }
  };
#+END_SRC
